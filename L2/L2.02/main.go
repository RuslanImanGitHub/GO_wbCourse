/*
Что выведет программа?
Объяснить порядок выполнения defer функций и итоговый вывод.
*/
package main

import "fmt"

func test() (x int) {
	defer func() {
		x++
	}()
	x = 1
	return
}

func anotherTest() int {
	var x int
	defer func() {
		x++
		fmt.Println(x)
	}()
	x = 1
	return x
}

func main() {
	fmt.Println(test())
	fmt.Println(anotherTest())
}

/*
Согласно блогу https://go.dev/blog/defer-panic-and-recover
Поведение defer идет по 3 правилам:
1. A deferred function’s arguments are evaluated when the defer statement is evaluated.
Аргументы отложенной функции вычисляются тогда же, когда выполняется оператор defer.
2. Deferred function calls are executed in Last In First Out order after the surrounding function returns.
Отложенные вызовы функций выполняются в порядке LIFO (Last-In-First-Out) после возврата из окружающей функции. (Не важно в этом случае)
3. Deferred functions may read and assign to the returning function’s named return values.
Отложенные функции могут читать и присваивать значения именованным переменным результата возвращающей функции.

Вывод вернет: test = 2, anotherTest = 1

Разбор test:
1. У функции есть именованная переменная результата x, тут же объявляется переменная x.
2. Вычисляются аргументы defer, он видит, что у родительской функции есть
именованная переменная результата x, следовательно ее нужно инкрементировать.
3. Присваиваем переменной x значение 1
4. Возвращаем функцию, т.к. функция имеет именованный результат, то он и возвращается, но перед тем как
функция вернет результат, этот результат идет в defer и инкрементируется, следовательно возвратится уже 2

Разбор anotherTest:
1. У функции нет именованной переменная результата
2. Объявляем переменную x
3. Вычисляются аргументы defer, он видит объявленную переменную x, и понимает, что ее нужно инкрементировать.
4. Присваиваем х значение 1
5. Возвращаем функцию, перед тем как вернется функция, запускается defer, он видит переменную х = 1, и инкрементирует ее, внутри defer х = 2,
но проблема в том, что согласно 3 правилу он не передаст значение x переменной внутри родительской функции, так как это не именованная
переменная результата. Можно увидеть, что в самом defer х=2 вызвав fmt.Println(x) в defer. Функция возвратит 1.
*/
