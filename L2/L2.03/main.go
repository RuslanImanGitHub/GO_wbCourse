/*
Что выведет программа?
Объяснить внутреннее устройство интерфейсов и их отличие от пустых интерфейсов.
*/

package main

import (
	"fmt"
	"os"
	"reflect"
)

func Foo() error {
	var err *os.PathError = nil
	return err
}

func main() {
	err := Foo()
	fmt.Println("Тип:", reflect.TypeOf(err))
	fmt.Println("Значение:", err)
	fmt.Println("err = nil:", err == nil)

	fmt.Println()

	var err2 error
	fmt.Println("Тип:", reflect.TypeOf(err2))
	fmt.Println("Значение:", err2)
	fmt.Println("err = nil:", err2 == nil)
}

/*
Вывод программы: <nil> и false, на вид возникает противоречие, но тут прикол в том, что
Интерфейс в Go это структура из 2 компонентов:
1. Информация о типе и методах типа
2. Указатель на конкретное значение

В Foo() мы создаем ошибу типа fs.PathError со значение nil, вывод через fmt показывает значение ошибки = nil,
а вот сравнивание с nil в общем случае структур выполняет сравнивание по всем полям структур, если их можно сравнить,
и собственно показывает, что одно из полей все таки не nil. Я модифицировал вывод так чтобы он показывал и тип
и значение ошибки. Чтобы можно было понять в чем подвох.

Также добавил создание ошибки без типа, чтобы показать, что если не задать тип, то сравнивание с nil даст
положительный результат
*/
